#' Function to filter nodes from networks generated by \code{asvNet}.
#'
#' @param net Object returned from \link{asvNet}.
#' @param trait A node trait to filter data using. This should be a column name in net$nodes.
#' @param filter Value to filter nodes by. How this is used depends on the type argument. For
#' numeric traits this can be a number or a character (0.9 or "0.9") with the character option
#' corresponding to quantiles (in this example the 90th percentile). For character traits this
#' should be a character vector and nodes with values of trait in that vector will be kept.
#' @param type type of comparison to make out of "ge", "le", and "in". Defaults to NULL in which case
#' "in" is used for character traits and "ge" is used for numeric traits. Note "ge" and "le" are
#' greater than or equal to and less than or equal to, respectively.
#' @param replot Logical, should nodes be rearranged to represent the network better visually?
#' Defaults to TRUE.
#' @importFrom stats quantile
#' @return A modified version of net with filtered nodes (and edges to those nodes).
#'
#' @examples
#'
#' taxa <- c(
#'   "Bacteria", "Proteobacteria", "Betaproteobacteria", "Burkholderiales",
#'   "Burkholderiaceae", "Paraburkholderia", NA
#' )
#' taxa <- matrix(rep(taxa, 10), nrow = 10, byrow = TRUE)
#' colnames(taxa) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")
#' rownames(taxa) <- paste0("ASV", 1:10)
#' # taxonomy data if used should have ASV names explicitly as a column
#' taxa_df <- as.data.frame(taxa)
#' taxa_df$asv <- rownames(taxa_df)
#'
#' sp_dist <- asvDist(asv, method = "spearman", clr_transform = TRUE, edgeFilter = 0.5)
#' net_data <- asvNet(sp_dist, taxa_df, edge = "spearman_similarity")
#'
#' dim(net_data$nodes)
#' net_data2 <- nodeFilter(net_data, trait = "strength", filter = 7, type = NULL, replot = TRUE)
#' dim(net_data2$nodes)
#'
#' @export

nodeFilter <- function(net, trait = NULL, filter = NULL, type = NULL, replot = TRUE) {
  original_nodes <- net[["nodes"]]
  original_edges <- net[["edges"]]
  type <- .nodeFilterType(net, trait, type) # format type
  filter_for <- .nodeFilterCutoffs(net, trait, type, filter) # format filter
  # logical comparisons based on type
  if (type == "in") {
    nodes <- original_nodes[original_nodes[[trait]] %in% filter_for, ]
    removed_nodes <- original_nodes[!original_nodes[[trait]] %in% filter_for, ]
  } else if (type == "ge") {
    nodes <- original_nodes[original_nodes[[trait]] >= filter_for, ]
    removed_nodes <- original_nodes[original_nodes[[trait]] < filter_for, ]
  } else if (type == "le") {
    nodes <- original_nodes[original_nodes[[trait]] <= filter_for, ]
    removed_nodes <- original_nodes[original_nodes[[trait]] > filter_for, ]
  }
  keep_nodes <- nodes[[1]]
  # get list of new edges only connecting nodes that were kept
  edges <- original_edges[original_edges$to %in% keep_nodes & original_edges$from %in% keep_nodes, ]
  # get list of edges to remove in to|from syntax
  removed_edges <- original_edges[!original_edges$to %in% keep_nodes |
                                    !original_edges$from %in% keep_nodes, ]
  removed_edge_names <- paste(removed_edges$from, removed_edges$to, sep = "|")
  # overwrite components of net
  net[["edges"]] <- edges
  net[["nodes"]] <- nodes
  net[["graph"]] <- igraph::delete_edges(net[["graph"]], removed_edge_names)
  net[["graph"]] <- igraph::delete_vertices(net[["graph"]], removed_nodes[[1]])
  if (replot) {
    net <- .replotNodes(net_data = net)
  }
  return(net)
}

#' @keywords internal
#' @noRd

.nodeFilterCutoffs <- function(net, trait, type, filter) {
  cutoff <- filter
  if (filter %in% c("le", "ge") && is.character(filter)) {
    cutoff <- stats::quantile(net$nodes[[trait]], probs = as.numeric(filter))
  }
  return(cutoff)
}

#' @keywords internal
#' @noRd

.nodeFilterType <- function(net, trait, type) {
  if (is.null(type)) {
    trait_values <- net$nodes[[trait]]
    if (is.numeric(trait_values)) {
      type <- "ge"
    } else {
      type <- "in"
    }
  }
  return(type)
}
