#' Function to filter edges from networks generated by \code{asvNet}.
#'
#' @param net Object returned from \link{asvNet}.
#' @param filter Value to filter edges for. If non-NULL then only edges with edgeWeight greater than
#' this value are kept. This can be a character vector or a numeric, with character taken as a quantile
#' and numeric taken as a value to use as is.
#' @param edge Optional weighting for edges. Must be present in the "edges" of net. Default of NULL
#' will show equal size edges between all connected nodes.
#' @param direction Direction of filtering, "g" (the default) for greater than filter value, "l" for
#' less than filter value/quantile.
#' @param replot Logical, should nodes be rearranged to represent the network better visually?
#' Defaults to TRUE.
#' @importFrom stats quantile
#' @return A modified version of net with filtered edges (and nodes if any were now isolated).
#'
#' @examples
#'
#' taxa <- c(
#'   "Bacteria", "Proteobacteria", "Betaproteobacteria", "Burkholderiales",
#'   "Burkholderiaceae", "Paraburkholderia", NA
#' )
#' taxa <- matrix(rep(taxa, 10), nrow = 10, byrow = TRUE)
#' colnames(taxa) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")
#' rownames(taxa) <- paste0("ASV", 1:10)
#' # taxonomy data if used should have ASV names explicitly as a column
#' taxa_df <- as.data.frame(taxa)
#' taxa_df$asv <- rownames(taxa_df)
#'
#' sp_dist <- asvDist(asv, method = "spearman", clr_transform = TRUE, edgeFilter = 0.5)
#' net_data <- asvNet(sp_dist, taxa_df, edge = "spearman_similarity")
#' dim(net_data$edges)
#' net_data2 <- edgeFilter(net_data, 0.6)
#' dim(net_data2$edges)
#'
#' @export
#'

edgeFilter <- function(net, filter, edge = "spearman_similarity", direction = "g", replot = TRUE) {
  original_nodes <- net[["nodes"]]
  original_edges <- net[["edges"]]
  if (is.character(filter)) {
    cutoff <- stats::quantile(original_edges[[edge]], probs = as.numeric(filter))
    if (direction == "g") {
      edges <- original_edges[original_edges[[edge]] >= as.numeric(cutoff), ]
      removed_edges <- original_edges[original_edges[[edge]] < as.numeric(cutoff), ]
    } else {
      edges <- original_edges[original_edges[[edge]] <= as.numeric(cutoff), ]
      removed_edges <- original_edges[original_edges[[edge]] > as.numeric(cutoff), ]
    }
  } else if (is.numeric(filter)) {
    if (direction == "g") {
      edges <- original_edges[original_edges[[edge]] >= filter, ]
      removed_edges <- original_edges[original_edges[[edge]] < filter, ]
    } else {
      edges <- original_edges[original_edges[[edge]] <= filter, ]
      removed_edges <- original_edges[original_edges[[edge]] > filter, ]
    }
  }
  removed_edge_names <- paste(removed_edges$from, removed_edges$to, sep = "|")
  nodes <- original_nodes[original_nodes$asv %in% unique(c(edges$from, edges$to)), ]
  net[["edges"]] <- edges
  net[["nodes"]] <- nodes
  removed_nodes <- setdiff(original_nodes$asv, nodes$asv)
  net[["graph"]] <- igraph::delete_edges(net[["graph"]], removed_edge_names)
  net[["graph"]] <- igraph::delete_vertices(net[["graph"]], removed_nodes)
  if (replot) {
    net <- .replotNodes(net_data = net)
  }
  return(net)
}

#' @keywords internal
#' @noRd

.replotNodes <- function(net_data) {
  g <- net_data$graph
  nd <- as.data.frame(igraph::layout.auto(g))
  node_id_name <- "asv"
  nd[[node_id_name]] <- igraph::as_ids(igraph::V(g))
  nodes <- net_data$nodes
  nodes <- nodes[sort(nodes[[node_id_name]], index.return = TRUE)$ix, ]
  nd <- nd[sort(nd[[node_id_name]], index.return = TRUE)$ix, ]
  nodes$V1 <- nd$V1
  nodes$V2 <- nd$V2
  eg <- net_data$edges
  eg$from.x <- nd$V1[match(eg$from, nd[[node_id_name]])]
  eg$from.y <- nd$V2[match(eg$from, nd[[node_id_name]])]
  eg$to.x <- nd$V1[match(eg$to, nd[[node_id_name]])]
  eg$to.y <- nd$V2[match(eg$to, nd[[node_id_name]])]
  net_data$edges <- eg
  net_data$nodes <- nodes
  return(net_data)
}
